#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0
#
# Copyright (C) 2019 Netronome Systems, Inc.

"""Command line interface for reading from a mdir

Script providing an ability to test local patch series.
On single patch series is expected as generated by git format-patch.
"""

import argparse
import configparser
import os
import re
import queue

from core import cmd
from core import NIPA_DIR
from core import log_open_sec, log_end_sec, log_init
from core import Patch
from core import Series
from core import Tree
from core import Tester

config = configparser.ConfigParser()

config.add_section('dirs')
config.add_section('log')

config.set('log', 'type', 'org')
config.set('log', 'path', '.nipa.log')

results_dir = config.get('results', 'dir',
                         fallback=os.path.join(NIPA_DIR, "results"))

parser = argparse.ArgumentParser()

patch_arg = parser.add_mutually_exclusive_group(required=True)
patch_arg.add_argument('--patch', help='path to the patch file')
patch_arg.add_argument('--mdir', help='path to the directory with the patches')

parser.add_argument('--tree', required=True, help='path to the tree to test on')
parser.add_argument('--tree-name', default='unknown',
                    help='the tree name to expect')
parser.add_argument('--result-dir', default=results_dir,
                    help='the directory where results will be generated')


def run_tester(args, tree, series):
    """ Run the tester, report results as they appear """

    try:
        done = queue.Queue()
        pending = queue.Queue()
        tester = Tester(args.result_dir, tree, pending, done,
                        config=config)
        tester.start()

        pending.put(series)
        pending.put(None)
    except:
        tester.should_die = True
    finally:
        tester.join()


def load_patches(args):
    """ Load patches from specified location on disk """

    log_open_sec("Loading patches")
    try:
        if args.mdir:
            mdir = os.path.abspath(args.mdir)
            files = [os.path.join(mdir, f) for f in sorted(os.listdir(mdir))]
        else:
            files = [os.path.abspath(args.patch)]

        series = Series()
        series.tree_selection_comment = "ingest_mdir"
        series.tree_mark_expected = False

        for f in files:
            with open(f, 'r', encoding="utf-8") as fp:
                data = fp.read()
                if re.search(r"\[.* 0+/\d.*\]", data) and \
                   not re.search(r"\n@@ -\d", data):
                    series.set_cover_letter(data)
                else:
                    series.add_patch(Patch(data))
    finally:
        log_end_sec()

    return series


def main():
    """ Main function """

    args = parser.parse_args()

    args.tree = os.path.abspath(args.tree)

    log_init(config.get('log', 'type'), config.get('log', 'path'),
             force_single_thread=True)

    series = load_patches(args)

    try:
        tree = Tree(args.tree_name, args.tree_name, args.tree,
                    current_branch=True)
    except cmd.CmdError:
        print("Can't assertain tree state, is a valid branch checked out?")
        raise
    head = tree.head_hash()
    tree.git_checkout(head)

    if not tree.check_applies(series):
        print("Patch series does not apply cleanly to the tree")
        os.sys.exit(1)

    tree.git_reset(head, hard=True)

    run_tester(args, tree, series)
    tree.git_checkout(tree.branch)
    tree.git_reset(head, hard=True)

    # Summary hack
    os.system(f'for i in $(find {args.result_dir} -type f -name summary); do ' +
              'dir=$(dirname "$i"); ' +
              'head -n2 "$dir"/summary; ' +
              'cat "$dir"/desc 2>/dev/null; done'
    )


if __name__ == "__main__":
    main()
