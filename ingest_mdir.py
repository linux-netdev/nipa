#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0
#
# Copyright (C) 2019 Netronome Systems, Inc.

"""Command line interface for reading from a mdir

Script providing an ability to test local patch series.
On single patch series is expected as generated by git format-patch.
"""

import argparse
import configparser
import os
import re
import queue
import tempfile

from core import cmd
from core import log_open_sec, log_end_sec, log_init
from core import Patch
from core import Series
from core import Tree
from core import Tester

config = configparser.ConfigParser()

config.add_section('dirs')
config.add_section('log')

parser = argparse.ArgumentParser()

patch_arg = parser.add_mutually_exclusive_group(required=True)
patch_arg.add_argument('--patch', help='path to the patch file')
patch_arg.add_argument('--mdir', help='path to the directory with the patches')

parser.add_argument('--tree', required=True, help='path to the tree to test on')
parser.add_argument('--tree-name', help='the tree name to expect')
parser.add_argument('--result-dir',
                    help='the directory where results will be generated')


def get_series_id(result_dir):
    """ Find an unused series ID. """

    i = 1
    while os.path.exists(os.path.join(result_dir, str(i))):
        i += 1
    return i


def run_tester(args, tree, series):
    """ Run the tester, report results as they appear """

    try:
        done = queue.Queue()
        pending = queue.Queue()
        tester = Tester(args.result_dir, tree, pending, done,
                        config=config)
        tester.start()

        pending.put(series)
        pending.put(None)
    except:
        tester.should_die = True
    finally:
        tester.join()


def load_patches(args):
    """ Load patches from specified location on disk """

    series_id = get_series_id(args.result_dir)

    log_open_sec("Loading patches")
    try:
        if args.mdir:
            mdir = os.path.abspath(args.mdir)
            files = [os.path.join(mdir, f) for f in sorted(os.listdir(mdir))]
        else:
            files = [os.path.abspath(args.patch)]

        series = Series(ident=series_id)
        series.tree_selection_comment = "ingest_mdir"
        series.tree_mark_expected = False

        for f in files:
            with open(f, 'r', encoding="utf-8") as fp:
                data = fp.read()
                if re.search(r"\[.* 0+/\d.*\]", data) and \
                   not re.search(r"\n@@ -\d", data):
                    series.set_cover_letter(data)
                else:
                    series.add_patch(Patch(data))
    finally:
        log_end_sec()

    return series


def main():
    """ Main function """

    args = parser.parse_args()

    args.tree = os.path.abspath(args.tree)

    if args.result_dir is None:
        args.result_dir = tempfile.mkdtemp()
    print("Saving output and logs to:", args.result_dir)

    config.set('log', 'type', 'org')
    config.set('log', 'dir', args.result_dir)
    config.set('log', 'path', "nipa.log")

    log_init(config.get('log', 'type'),
             os.path.join(args.result_dir, 'nipa.log'),
             force_single_thread=True)

    series = load_patches(args)

    tree_name = args.tree_name
    if tree_name is None:
        # Try to guess tree name from the patch subject, expecting subject
        # to be something like [PATCH tree-name 2/N].
        tags = re.search(
            r'Subject: \[(?:PATCH|RFC) (?:v\d+ )?([a-zA-Z-]+)(?: v\d+)?(?: \d*\/\d*)?\]',
            series.patches[0].raw_patch
        )
        if tags:
            tree_name = tags.group(1).strip()
            print("Tree name extracted from patches:", tree_name)
        else:
            tree_name = "unknown"
            print("Tree name unknown")

    try:
        tree = Tree(tree_name, tree_name, args.tree, current_branch=True)
    except cmd.CmdError:
        print("Can't assertain tree state, is a valid branch checked out?")
        raise
    head = tree.head_hash()
    tree.git_checkout(head)

    if not tree.check_applies(series):
        print("Patch series does not apply cleanly to the tree")
        os.sys.exit(1)

    tree.git_reset(head, hard=True)

    run_tester(args, tree, series)
    tree.git_checkout(tree.branch)
    tree.git_reset(head, hard=True)

    # Summary hack
    os.system(f'for i in $(find {args.result_dir}/{series.id} -type f -name summary); do ' +
              'dir=$(dirname "$i"); ' +
              'head -n2 "$dir"/summary; ' +
              'cat "$dir"/desc 2>/dev/null; done'
    )


if __name__ == "__main__":
    main()
