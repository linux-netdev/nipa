#!/usr/bin/env python3
# SPDX-License-Identifier: GPL-2.0
#
# Copyright (C) 2019 Netronome Systems, Inc.

"""Command line interface for reading from a mdir

Script providing an ability to test local patch series.
On single patch series is expected as generated by git format-patch.
"""

import argparse
import configparser
import os
import re
import threading
import queue

from core import NIPA_DIR
from core import log, log_open_sec, log_end_sec, log_init
from core import Patch
from core import Series
from core import Tree
from core import Tester

config = configparser.ConfigParser()
config.read(['nipa.config', "tester.config"])

results_dir = config.get('results', 'dir',
                         fallback=os.path.join(NIPA_DIR, "results"))

# TODO: use config
parser = argparse.ArgumentParser()
parser.add_argument('--mdir', required=True,
                    help='path to the directory with the patches')
parser.add_argument('--tree', required=True,
                    help='path to the tree to test on')
parser.add_argument('--tree-name', default='unknown',
                    help='the tree name to expect')
parser.add_argument('--tree-branch', default='master',
                    help='the branch or commit to use as a base for applying patches')
parser.add_argument('--result-dir', default=results_dir,
                    help='the directory where results will be generated')
args = parser.parse_args()

args.mdir = os.path.abspath(args.mdir)
args.tree = os.path.abspath(args.tree)

log_init(config.get('log', 'type'), config.get('log', 'path'), force_single_thread=True)

log_open_sec("Loading patches")
try:
    files = [os.path.join(args.mdir, f) for f in sorted(os.listdir(args.mdir))]
    series = Series()
    series.tree_selection_comment = "ingest_mdir"
    series.tree_mark_expected = False

    for f in files:
        with open(f, 'r') as fp:
            data = fp.read()
            if re.search(r"\[.* 0+/\d.*\]", data) and \
               not re.search(r"\n@@ -\d", data):
                series.set_cover_letter(data)
            else:
                series.add_patch(Patch(data))
finally:
    log_end_sec()

tree = Tree(args.tree_name, args.tree_name, args.tree, branch=args.tree_branch)
if not tree.check_applies(series):
    print("Patch series does not apply cleanly to the tree")
    os.sys.exit(1)

try:
    done = queue.Queue()
    pending = queue.Queue()
    barrier = threading.Barrier(2)
    tester = Tester(args.result_dir, tree, pending, done, barrier)
    tester.start()

    pending.put(series)

    # Unleash all workers
    log("Activate workers", "")
    barrier.wait()

    # Wait for workers to come back
    log("Wait for workers", "")
    barrier.wait()

    # Shut workers down
    tester.should_die = True
    pending.put(None)
    barrier.wait()

finally:
    barrier.abort()
    tester.should_die = True
    pending.put(None)
    tester.join()

# Summary hack
os.system(f'for i in $(find {args.result_dir} -type f -name summary); do dir=$(dirname "$i"); head -n2 "$dir"/summary; cat "$dir"/desc 2>/dev/null; done')
